#include <Arduino.h>
#include <Ramp.h>
#include <esp_now.h>
#include <WiFi.h>
#include <SimpleFOC.h>
#include <cmath>
#include <array>
#include <PSX.h>

#define DATA_PIN 13
#define CMD_PIN 12
#define ATT_PIN 15
#define CLOCK_PIN 14

PSX psx;

PSX::PSXDATA PSXdata;
int PSXerror;

//receiver MAC Address

uint8_t peerMac[6][6] = {
  {0x24, 0x6F, 0x28, 0xAE, 0x5C, 0xD4}, // Front-Upper
  {0x24, 0x6F, 0x28, 0xAE, 0x5C, 0xD4}, // Front-Middle
  {0x24, 0x6F, 0x28, 0xAE, 0x5C, 0xD4}, // Front-Lower
  {0x24, 0x6F, 0x28, 0xAE, 0x5C, 0xD4}, // Back-Upper
  {0x24, 0x6F, 0x28, 0xAE, 0x5C, 0xD4}, // Back-Middle
  {0x24, 0x6F, 0x28, 0xAE, 0x5C, 0xD4}  // Back-Lower
};

enum states {
  STATE_IDLE = 0,
  STATE_WALKING = 1,
  STATE_TURNING = 2
};

enum ControlCommand : uint8_t {
  CMD_NONE = 0,
  CMD_INIT = 1,
  CMD_STOP = 2
};

typedef struct {
  uint8_t command;
  float thetal;
  float thetar;
} ControlPacket;

ControlPacket outgoingInformation;

String success;

// ==============================
// --- GLOBAL VARIABLES ---
// ==============================

double magnitude = 0.0;
ramp velocityRamp[2]; // Ramp for smooth transitions

double angle = 0; // 0-360 degrees, 0 = forward
double maxAngleSpeed = 90; // degrees per second

double tiltState[2] = {0, 0}; // [0] = pitch (i/k), [1] = roll (j/l)
double pitchTheta = 30; // degrees
double rollTheta = 20;  // degrees
ramp currentPitch;
ramp currentRoll;

unsigned long lastSendTime = 0;
const unsigned long sendInterval = 50; // milliseconds

double langle;
double lagnitude;

double rangle;
double ragnitude;

void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  if (status ==0){
    success = "Delivery Success :)";
  }
  else{
    success = "Delivery Fail :(";
  }
}

void processSerialInput() {
  static unsigned long lastKeyTime = 0;
  const unsigned long centerTimeout = 500; // milliseconds before centering

  if (Serial.available()) {
    char c = Serial.read();
    lastKeyTime = millis();

    // Velocity control (WASD)
    if (c == 'w') velocityRamp[0].go(2.0, 200);   // Forward
    if (c == 's') velocityRamp[0].go(0.0, 200);  // Backward
    if (c == 'a') velocityRamp[1].go(0.0, 200);  // Left
    if (c == 'd') velocityRamp[1].go(2.0, 200);   // Right

    // Tilt control (IJKL)
    //if (c == 'i') currentPitch.go(pitchTheta * M_PI / 180.0, 0.3);   // Pitch up
    //if (c == 'k') currentPitch.go(-pitchTheta * M_PI / 180.0, 0.3);  // Pitch down
    //if (c == 'j') currentRoll.go(-rollTheta * M_PI / 180.0, 0.3);    // Roll left
    //if (c == 'l') currentRoll.go(rollTheta * M_PI / 180.0, 0.3);     // Roll right

    if (c == 'h') {
      outgoingInformation.command = CMD_INIT;
      esp_now_send((uint8_t*)"\xFF\xFF\xFF\xFF\xFF\xFF",(uint8_t*)&outgoingInformation,sizeof(outgoingInformation));
      outgoingInformation.command = CMD_NONE;
    }
  }

  // Center if no key pressed for timeout duration
  if (millis() - lastKeyTime >= centerTimeout) {
    velocityRamp[0].go(1, 200);
    velocityRamp[1].go(1, 200);
    currentPitch.go(0, 300);
    currentRoll.go(0, 300);
  }

  double vr0 = velocityRamp[0].update()-1.0;
  double vr1 = velocityRamp[1].update()-1.0;

  angle = atan2(vr1, vr0) * 180.0 / M_PI;
  double multiplier = 0.0;
  if (abs(vr0) >= abs(vr1)) {
    multiplier = 1/sqrt(1 + abs(vr1/vr0));
  } else {
    multiplier = 1/sqrt(1 + abs(vr0/vr1));    
  }
  if (vr0 == 0 || vr1 == 0) multiplier = 1.0;
  magnitude = sqrt(vr0*vr0 + vr1*vr1) * multiplier;
}

std::array<double, 3> inverseKinematics(double x, double y, double z, bool isFrontLeg, bool isRightLeg) {
  double h = hipLength;
  double t = thighLength;
  double k = kneeLength;

  x += 0.15;
  y -= 0.3535;
  z += 0.0;

  y += (isFrontLeg ? 1 : -1) * (frontBackJointDistance / 2) * tan(currentpitch.update());
  y += (isRightLeg ? -1 : 1) * (leftRightJointDistance / 2) * tan(currentroll.update());

  double p = std::sqrt(std::max(x*x + y*y - h*h, 0.0));
  double L = std::sqrt(p*p + z*z);

  double theta1 = atan2(y, x);
  double cosTerm = (k*k - L*L - t*t) / (-2.0 * L * t);
  cosTerm = std::max(-1.0, std::min(1.0, cosTerm));
  double theta2 = M_PI/2.0 - std::acos(cosTerm) + atan2(z, p);

  double cosTheta3 = (L*L - k*k - t*t) / (-2.0 * k * t);
  cosTheta3 = std::max(-1.0, std::min(1.0, cosTheta3));
  double theta3 = std::acos(cosTheta3);

  theta2 += currentpitch.update();
  theta1 += (isRightLeg ? -1 : 1) * currentroll.update();

  theta1 *= gearRatio;
  theta2 *= gearRatio;
  theta3 *= gearRatio;

  return {theta1, theta2, theta3};
}

std::array<float, 12> calculateAngles() {
  float thetafr1, thetafr2, thetafr3;
  float thetafl1, thetafl2, thetafl3;
  float backright1, backright2, backright3;
  float backleft1, backleft2, backleft3;
  
  float stepCycleTime = 1000.0; // milliseconds
  

  return {thetafr1, thetafr2, thetafr3,
          thetafl1, thetafl2, thetafl3,
          backright1, backright2, backright3,
          backleft1, backleft2, backleft3};
}

void addPeers() {
  esp_now_peer_info_t peerInfo = {};
  peerInfo.channel = 0;     // must match receiver WiFi channel
  peerInfo.encrypt = false;

  for (int i = 0; i <= 5; i++) {
    memcpy(peerInfo.peer_addr, peerMac[i], 6);

    if (esp_now_add_peer(&peerInfo) != ESP_OK) {
      Serial.print("Failed to add peer ");
      Serial.println(i);
    }
  }
}

void sendData() {
  unsigned long currentTime = millis();
  if (currentTime - lastSendTime >= sendInterval) {
    lastSendTime = currentTime;
    std::array<float, 12> angles = calculateAngles();
    for (int i = 0; i <= 5; i++) {
      outgoingInformation.thetal = angles[0]; // Example assignment
      outgoingInformation.thetar = angles[1]; // Example assignment
      esp_now_send(peerMac[i],(uint8_t*)&outgoingInformation,sizeof(outgoingInformation));
    }
  }
}

void processPSData() {

  PSXerror = psx.read(PSXdata);

  
  if(PSXerror == PSXERROR_SUCCESS) {
  Serial.println("controller success");
  } else {
  Serial.print("No success reading data. Check connections and timing.");
  }
  
  if(PSXdata.buttons & PSXBTN_START) {
    outgoingInformation.command = CMD_INIT;
    esp_now_send((uint8_t*)"\xFF\xFF\xFF\xFF\xFF\xFF",(uint8_t*)&outgoingInformation,sizeof(outgoingInformation));
    outgoingInformation.command = CMD_NONE;
  }

  //read data
  float LeftX = PSXdata.JoyLeftX; // 0-2
  float LeftY = PSXdata.JoyLeftY;
  float RightX = PSXdata.JoyRightX;
  float RightY = PSXdata.JoyRightY;
  
  //if not touching center
  if (126 < LeftX < 130 || 126 < LeftY < 130) {
    velocityRamp[0].go(1.0, 200); // Center
    velocityRamp[1].go(1.0, 200); // Center
  } else { //else process input
    // normalize to 0 to 2
    double LX = LeftX / 128.0; // 0 to 2
    double LY = LeftY / 128.0; // 0 to 2

    //go to between 0 or 2
    velocityRamp[0].go(LX, 200);
    velocityRamp[1].go(LY, 200);
  }

   //go to -1 to 1
    double vr0 = velocityRamp[0].update()-1.0;
    double vr1 = velocityRamp[1].update()-1.0;

    //constrain
    vr0 = constrain(vr0, -1.0, 1.0);
    vr1 = constrain(vr1, -1.0, 1.0);

    //from square to circle
    double xc = vr0 * sqrt(1.0 - (vr1*vr1)/2.0);
    double yc = vr1 * sqrt(1.0 - (vr0*vr0)/2.0);

    //theta, magnitude
    langle = atan2(yc, xc);            // radians (-π to +π)
    lagnitude = sqrt(xc*xc + yc*yc);  // 0 → 1

}

void stepMotion() {
  static double stepHeight = 0.075;
  static double stepLength = 4 * stepHeight;

  static double xyz[3] = {0, 0, 0};
  static unsigned long lastLoop = millis();
  double time = (millis() - lastLoop) / 1000.0;
  static double halfloopTime = 3.0;
  static double returnTime = 3.0;

  if (time > halfloopTime) {
    xyz[1] = 0;
    xyz[2] = stepLength*0.5*cos((time-halfloopTime)/halfloopTime*PI);
  } else {
    xyz[1] = stepHeight*sin(time/halfloopTime*PI);
    xyz[2] = -stepLength*0.5*cos(time/halfloopTime*PI);
  }
  if (time > halfloopTime + returnTime) lastLoop = millis();

  double x = xyz[2] * lagnitude * sin(langle);
  double z = xyz[2] * lagnitude * cos(langle);

  std::array<double, 3> moveTarget = inverseKinematics(x, xyz[1], z, true, true);
  //Serial.println("coords" + String(x) + "," + String(xyz[1]) + "," + String(z) + " angles " + String(moveTarget[0]) + "," + String(moveTarget[1]) + "," + String(moveTarget[2]));

  // if you have knee motor: FRTmotor.move(moveTarget[0]);
  FRHmotor.move(moveTarget[1]);
  //FRKmotor.move(moveTarget[2]);
}

// ==============================
// --- SETUP & LOOP ---
// ==============================

void setup() {
  Serial.begin(9600);
  // Set device as a Wi-Fi Station
  WiFi.mode(WIFI_STA);

  // Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }

  addPeers();

  // Once ESPNow is successfully Init, we will register for Send CB to
  // get the status of Trasnmitted packet
  esp_now_register_send_cb(esp_now_send_cb_t(OnDataSent));

  psx.setupPins(DATA_PIN, CMD_PIN, ATT_PIN, CLOCK_PIN, 10);
  psx.config(PSXMODE_ANALOG);

  }


void loop() {
  processSerialInput();
  processPSData();
  sendData();
}