#include <Arduino.h>
#include <Ramp.h>
#include <esp_now.h>
#include <WiFi.h>
#include <SimpleFOC.h>
#include <cmath>
#include <array>

//receiver MAC Address
uint8_t receiverAddresses[6][6] = {
    {0x24, 0x6F, 0x28, 0xAE, 0x5C, 0xD4},
    {0x24, 0x6F, 0x28, 0xB0, 0x3C, 0xA0},
    {0x24, 0x6F, 0x28, 0xB0, 0x39, 0xE0},
    {0x24, 0x6F, 0x28, 0xAE, 0x5D, 0x00},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}
};

esp_now_peer_info_t peerInfos[6];

typedef struct struct_message {
    double magnitude;
    double angle;
    double tiltState[2];
    double tiltTarget[2];
} struct_message;

struct_message outgoingInformation;

String success;

void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.print("\r\nLast Packet Send Status:\t");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
  if (status ==0){
    success = "Delivery Success :)";
  }
  else{
    success = "Delivery Fail :(";
  }
}


// ==============================
// --- GLOBAL VARIABLES ---
// ==============================

double magnitude = 0.0;
ramp velocityRamp[2]; // Ramp for smooth transitions

double angle = 0; // 0-360 degrees, 0 = forward
double maxAngleSpeed = 90; // degrees per second

double tiltState[2] = {0, 0}; // [0] = pitch (i/k), [1] = roll (j/l)
double pitchTheta = 30; // degrees
double rollTheta = 20;  // degrees
ramp currentPitch;
ramp currentRoll;

unsigned long lastSendTime = 0;
const unsigned long sendInterval = 50; // milliseconds

// ==============================
// --- SERIAL INPUT PROCESSING ---
// ==============================

void processSerialInput() {
  static unsigned long lastKeyTime = 0;
  const unsigned long centerTimeout = 500; // milliseconds before centering

  if (Serial.available()) {
    char c = Serial.read();
    lastKeyTime = millis();

    // Velocity control (WASD)
    if (c == 'w') velocityRamp[0].go(2.0, 0.2);   // Forward
    if (c == 's') velocityRamp[0].go(0.0, 0.2);  // Backward
    if (c == 'a') velocityRamp[1].go(0.0, 0.2);  // Left
    if (c == 'd') velocityRamp[1].go(2.0, 0.2);   // Right

    // Tilt control (IJKL)
    if (c == 'i') currentPitch.go(pitchTheta * M_PI / 180.0, 0.3);   // Pitch up
    if (c == 'k') currentPitch.go(-pitchTheta * M_PI / 180.0, 0.3);  // Pitch down
    if (c == 'j') currentRoll.go(-rollTheta * M_PI / 180.0, 0.3);    // Roll left
    if (c == 'l') currentRoll.go(rollTheta * M_PI / 180.0, 0.3);     // Roll right
  }

  // Center if no key pressed for timeout duration
  if (millis() - lastKeyTime >= centerTimeout) {
    velocityRamp[0].go(1, 0.2);
    velocityRamp[1].go(1, 0.2);
    currentPitch.go(0, 0.3);
    currentRoll.go(0, 0.3);
  }

  double vr0 = velocityRamp[0].update()-1.0;
  double vr1 = velocityRamp[1].update()-1.0;

  angle = atan2(vr1, vr0) * 180.0 / M_PI;
  double multiplier = 0.0;
  if (abs(vr0) >= abs(vr1)) {
    multiplier = 1/sqrt(1 + abs(vr1/vr0));
  } else {
    multiplier = 1/sqrt(1 + abs(vr0/vr1));    
  }
  if (vr0 == 0 || vr1 == 0) multiplier = 1.0;
  magnitude = sqrt(vr0*vr0 + vr1*vr1) * multiplier;
}

// ==============================
// --- SERIAL OUTPUT ---
// ==============================

void sendData() {
  unsigned long currentTime = millis();
  if (currentTime - lastSendTime >= sendInterval) {
    lastSendTime = currentTime;

    // Format: angle,velocity_forward,velocity_strafe,pitch,roll
    Serial.print(angle);
    Serial.print(",");
    Serial.print(magnitude);
    Serial.print(",");
    Serial.print(currentPitch.update());
    Serial.print(",");
    Serial.println(currentRoll.update());
    outgoingInformation.magnitude = magnitude;
    outgoingInformation.angle = angle;
    outgoingInformation.tiltState[0] = currentPitch.update();
    outgoingInformation.tiltState[1] = currentRoll.update();
    outgoingInformation.tiltTarget[0] = 0;
    outgoingInformation.tiltTarget[1] = 0; // to be added later

  }
}

// ==============================
// --- SETUP & LOOP ---
// ==============================

void setup() {
  Serial.begin(9600);
  // Set device as a Wi-Fi Station
  WiFi.mode(WIFI_STA);

  // Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }

  // Once ESPNow is successfully Init, we will register for Send CB to
  // get the status of Trasnmitted packet
  esp_now_register_send_cb(esp_now_send_cb_t(OnDataSent));
  
  // Register peer
  for (int i = 0; i < 6; i++) {
    memcpy(peerInfos[i].peer_addr, receiverAddresses[i], 6);
    peerInfos[i].channel = 0;
    peerInfos[i].encrypt = false;
    if (esp_now_add_peer(&peerInfos[i]) != ESP_OK) {
      Serial.println("Failed to add peer");
      return;
    }
  }
}

void loop() {
  processSerialInput();
  sendData();
}