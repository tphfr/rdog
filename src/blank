// MKS DUAL FOC open-loop speed control routine.Test library: SimpleFOC 2.1.1 Test hardware: MKS DUAL FOC V3.1
// Enter "T+number" in the serial port to set the speed of the two motors. For example, set the motor to rotate at 10rad/s, input "T10", and the motor will rotate at 5rad/s by default when it is powered on
// When using your own motor, please remember to modify the default number of pole pairs, that is, the value in BLDCMotor(7), and set it to your own number of pole pairs
// The default power supply voltage set by the program is 12V, please remember to modify the values in voltage_power_supply and voltage_limit variables if you use other voltages for power supply

#include <SimpleFOC.h>
#include <cmath>
#include <array>
#include <Ramp.h>


double position[3] = {0, 0, 0};

//distance from hip's rotation axis to the knee driver gear, all in meters
double hipLength = 0.15;
double thighLength = 0.25;
double kneeLength = 0.25;
double frontBackJointDistance = 0.6;
double leftRightJointDistance = 0.3;

ramp xreadings;
ramp yreadings;
ramp stepping;


double pitchtheta = 0; // in radians
double rolltheta = 0; // in radians
double yawtheta = 0; // in radians

double degAngles[3] = {0, 0, 0};

BLDCMotor FRHmotor = BLDCMotor(11);
BLDCDriver3PWM FRHdriver = BLDCDriver3PWM(32,33,25);
MagneticSensorI2C FRHsensor = MagneticSensorI2C(AS5600_I2C);
TwoWire FRHI2C = TwoWire(0);

BLDCMotor FRTmotor = BLDCMotor(11);
BLDCDriver3PWM FRTdriver  = BLDCDriver3PWM(26,27,14);
MagneticSensorI2C FRTsensor = MagneticSensorI2C(AS5600_I2C);
TwoWire FRTI2C = TwoWire(1);

BLDCMotor FRKmotor = BLDCMotor(11);
BLDCDriver3PWM FRKdriver  = BLDCDriver3PWM(26,27,14);
MagneticSensorI2C FRKsensor = MagneticSensorI2C(AS5600_I2C);
TwoWire FRKI2C = TwoWire(2);

// Constants: t, h, k
// Input: x, y, z
// Output: theta1, theta2, theta3 (in degrees, shifted origin)

std::array<double, 3> forwardKinematics(double theta1, double theta2, double theta3) {
    // --- Step 1: shift angles back to "math origin" (undo calibration) ---

    // --- Step 2: convert to radians ---
    double t1 = theta1 * M_PI / 180.0;
    double t2 = theta2 * M_PI / 180.0;
    double t3 = theta3 * M_PI / 180.0;

    // --- Step 3: compute helper distance ---
    double r = (thighLength - kneeLength * cos(t3)) * sin(t2) + (kneeLength * sin(t3)) * cos(t2);

    // --- Step 4: compute x, y, z ---
    double x = hipLength * sin(t1) - r * cos(t1);
    double y = -hipLength * cos(t1) - r * sin(t1);
    double z = -(thighLength - kneeLength * cos(t3)) * cos(t2) + (kneeLength * sin(t3)) * sin(t2);

    return {x, y, z};
}

std::array<double, 3> inverseKinematics(double x, double y, double z, bool isFrontLeg, bool isRightLeg) {
    double h = hipLength;
    double t = thighLength;
    double k = kneeLength;

  //offset
  x += 0.15;
  y -= 0.3535;
  z += 0.0;

  
    if (isFrontLeg) {
    y += (frontBackJointDistance/2)*tan(pitchtheta);
  } else {
    y -= (frontBackJointDistance/2)*tan(pitchtheta);
  }

  if (isRightLeg) {
    y -= (leftRightJointDistance/2)*tan(rolltheta);
  } else {
    y += (leftRightJointDistance/2)*tan(rolltheta);
  }

    // Step 1: p = sqrt(x² + z² - h²)
    double p = std::sqrt(std::max(x*x + y*y - h*h, 0.0));

    // Step 2: L = sqrt(p² + y²)
    double L = std::sqrt(p*p + z*z);

    // Step 3: θ1 depends on z sign
    double theta1;
    if (y <= 0) {
        theta1 = std::atan2(x, -y) + std::atan2(p, h);
    } else {
        theta1 = std::atan2(y, x) + std::atan2(p, h) + M_PI/2.0;
    }

    // Step 4: θ2
    double cosTerm = (k*k - L*L - t*t) / (-2.0 * L * t);
    cosTerm = std::max(-1.0, std::min(1.0, cosTerm)); // safe clamp
    double theta2 = M_PI/2.0 - std::acos(cosTerm) + std::atan2(z, p);

    // Step 5: θ3
    double cosTheta3 = (L*L - k*k - t*t) / (-2.0 * k * t);
    cosTheta3 = std::max(-1.0, std::min(1.0, cosTheta3));
    double theta3 = std::acos(cosTheta3);

    // Step 6: Convert to degrees
    theta1 *= 180.0 / M_PI;
    theta2 *= 180.0 / M_PI;
    theta3 *= 180.0 / M_PI;

    return {theta1, theta2, theta3};
}

double PRControl() {
    //establish current tilt from the input e.g. pitch +5 degrees, roll -5 degrees
    //get imu readings
    //compensate the imu by pitch -5 degrees, roll +5 degrees
    //set as current pitch and roll angles
    //if not angled zero, rotate the motors by that degree additionally so thatt the feet point flat to the ground
}

static double stepHeight = 0.05; //meters
static double stepLength = 1.2 * stepHeight; //meters

double stepMotion() {
  
  double x1 = 1; //change to controller readings
  double y1 = 0; //change to controller readings
  xreadings.go(x1,0.5);
  yreadings.go(y1,0.5);

  double maxDirectionalMagnitude = 1; //change to max readings
  double directionalAngle = atan2(yreadings.update(), xreadings.update()); //change to readings
  double directionalMagnitudeCoefficient = sqrt(xreadings.update()*xreadings.update() + yreadings.update()*yreadings.update())/maxDirectionalMagnitude; //change to readings
  //create x y z coordinates in a half circle path forward

  static double xyz[3] = {0,0,0};
  static double lastLoop = millis();
  double time = (millis() - lastLoop) / 1000.0; // seconds
  static double halfloopTime = 0.5;
  static double returnTime = 0.5;
  if (time > halfloopTime) {
      xyz[1] = 0;
      xyz[2] = stepLength*0.5*cos(0)+stepLength*0.5*cos((time-halfloopTime)/halfloopTime*PI);
    } else {
      xyz[1] = stepHeight*sin(time/halfloopTime*PI);
      xyz[2] = stepLength*0.5*cos(0)-stepLength*0.5*cos(time/halfloopTime*PI);
    }
  if (time > halfloopTime + returnTime) {
      lastLoop = millis();
  }


  //transform that x y z into angled using directional angle
  double x = xyz[2] * directionalMagnitudeCoefficient * sin(directionalAngle);
  double z = xyz[2] * directionalMagnitudeCoefficient * cos(directionalAngle);
  //send those angles to inverse kinematics
  std::array<double, 3> moveTarget = inverseKinematics(x, xyz[1], z, true, true);
  //move to those angles
  FRHmotor.move(moveTarget[0]);
  FRTmotor.move(moveTarget[1]);
  FRKmotor.move(moveTarget[2]);
  return 0;
} 

void setup () {
  Serial.begin(9600);
  Serial.println("Inverse Kinematics Ready");
}

void processSerialInput() {
    if (Serial.available()) {
        String input = Serial.readStringUntil('\n');
        input.trim();

        if (input.startsWith("T")) {
            // Process as angles: Ttheta1,theta2,theta3
            input.remove(0, 1); // Remove the 'T'
            int firstComma = input.indexOf(',');
            int secondComma = input.indexOf(',', firstComma + 1);

            if (firstComma > 0 && secondComma > firstComma) {
                double theta1 = input.substring(0, firstComma).toDouble();
                double theta2 = input.substring(firstComma + 1, secondComma).toDouble();
                double theta3 = input.substring(secondComma + 1).toDouble();

                std::array<double, 3> coords = forwardKinematics(theta1, theta2, theta3);
                Serial.print("X: "); Serial.println(coords[0]);
                Serial.print("Y: "); Serial.println(coords[1]);
                Serial.print("Z: "); Serial.println(coords[2]);
            } else {
                Serial.println("Invalid input. Use format: Ttheta1,theta2,theta3");
            }
        } else {
            // Process as coordinates: x,y,z
            int firstComma = input.indexOf(',');
            int secondComma = input.indexOf(',', firstComma + 1);

            if (firstComma > 0 && secondComma > firstComma) {
                double x = input.substring(0, firstComma).toDouble();
                double y = input.substring(firstComma + 1, secondComma).toDouble();
                double z = input.substring(secondComma + 1).toDouble();

                std::array<double, 3> angles = inverseKinematics(x, y, z, true, true);
                Serial.print(String(x) +" is Theta1: "); Serial.println(angles[0]);
                Serial.print(String(y) +" is Theta2: "); Serial.println(angles[1]);
                Serial.print(String(z) +" is Theta3: "); Serial.println(angles[2]);
            } else {
                Serial.println("Invalid input. Use format: x,y,z");
            }
        }
    }
}

void loop() {
    processSerialInput();
}