#include <Arduino.h>
#include <Ramp.h>
#include <esp_now.h>
#include <WiFi.h>
#include <SimpleFOC.h>
#include <cmath>
#include <array>

//receiver MAC Address

uint8_t peerMac[6][6] = {
  {0x24, 0x6F, 0x28, 0xAE, 0x5C, 0xD4}, // Front-Upper
  {0x24, 0x6F, 0x28, 0xAE, 0x5C, 0xD4}, // Front-Middle
  {0x24, 0x6F, 0x28, 0xAE, 0x5C, 0xD4}, // Front-Lower
  {0x24, 0x6F, 0x28, 0xAE, 0x5C, 0xD4}, // Back-Upper
  {0x24, 0x6F, 0x28, 0xAE, 0x5C, 0xD4}, // Back-Middle
  {0x24, 0x6F, 0x28, 0xAE, 0x5C, 0xD4}  // Back-Lower
};

enum states {
  STATE_IDLE = 0,
  STATE_WALKING = 1,
  STATE_TURNING = 2
};

enum ControlCommand : uint8_t {
  CMD_NONE = 0,
  CMD_INIT = 1,
  CMD_STOP = 2
};

typedef struct {
  uint8_t command;
  float thetal;
  float thetar;
} ControlPacket;

ControlPacket outgoingInformation;

String success;

void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  if (status ==0){
    success = "Delivery Success :)";
  }
  else{
    success = "Delivery Fail :(";
  }
}


// ==============================
// --- GLOBAL VARIABLES ---
// ==============================

double magnitude = 0.0;
ramp velocityRamp[2]; // Ramp for smooth transitions

double angle = 0; // 0-360 degrees, 0 = forward
double maxAngleSpeed = 90; // degrees per second

double tiltState[2] = {0, 0}; // [0] = pitch (i/k), [1] = roll (j/l)
double pitchTheta = 30; // degrees
double rollTheta = 20;  // degrees
ramp currentPitch;
ramp currentRoll;

unsigned long lastSendTime = 0;
const unsigned long sendInterval = 50; // milliseconds

// ==============================
// --- SERIAL INPUT PROCESSING ---
// ==============================

void processSerialInput() {
  static unsigned long lastKeyTime = 0;
  const unsigned long centerTimeout = 500; // milliseconds before centering

  if (Serial.available()) {
    char c = Serial.read();
    lastKeyTime = millis();

    // Velocity control (WASD)
    if (c == 'w') velocityRamp[0].go(2.0, 200);   // Forward
    if (c == 's') velocityRamp[0].go(0.0, 200);  // Backward
    if (c == 'a') velocityRamp[1].go(0.0, 200);  // Left
    if (c == 'd') velocityRamp[1].go(2.0, 200);   // Right

    // Tilt control (IJKL)
    //if (c == 'i') currentPitch.go(pitchTheta * M_PI / 180.0, 0.3);   // Pitch up
    //if (c == 'k') currentPitch.go(-pitchTheta * M_PI / 180.0, 0.3);  // Pitch down
    //if (c == 'j') currentRoll.go(-rollTheta * M_PI / 180.0, 0.3);    // Roll left
    //if (c == 'l') currentRoll.go(rollTheta * M_PI / 180.0, 0.3);     // Roll right

    if (c == 'h') {
      outgoingInformation.command = CMD_INIT;
      esp_now_send((uint8_t*)"\xFF\xFF\xFF\xFF\xFF\xFF",(uint8_t*)&outgoingInformation,sizeof(outgoingInformation));
      outgoingInformation.command = CMD_NONE;
    }
  }

  // Center if no key pressed for timeout duration
  if (millis() - lastKeyTime >= centerTimeout) {
    velocityRamp[0].go(1, 200);
    velocityRamp[1].go(1, 200);
    currentPitch.go(0, 300);
    currentRoll.go(0, 300);
  }

  double vr0 = velocityRamp[0].update()-1.0;
  double vr1 = velocityRamp[1].update()-1.0;

  angle = atan2(vr1, vr0) * 180.0 / M_PI;
  double multiplier = 0.0;
  if (abs(vr0) >= abs(vr1)) {
    multiplier = 1/sqrt(1 + abs(vr1/vr0));
  } else {
    multiplier = 1/sqrt(1 + abs(vr0/vr1));    
  }
  if (vr0 == 0 || vr1 == 0) multiplier = 1.0;
  magnitude = sqrt(vr0*vr0 + vr1*vr1) * multiplier;
}


std::array<float, 12> calculateAngles() {
  float thetafr1, thetafr2, thetafr3;
  float thetafl1, thetafl2, thetafl3;
  float backright1, backright2, backright3;
  float backleft1, backleft2, backleft3;
  
  float stepCycleTime = 1000.0; // milliseconds
  

  return {thetafr1, thetafr2, thetafr3,
          thetafl1, thetafl2, thetafl3,
          backright1, backright2, backright3,
          backleft1, backleft2, backleft3};
}

void addPeers() {
  esp_now_peer_info_t peerInfo = {};
  peerInfo.channel = 0;     // must match receiver WiFi channel
  peerInfo.encrypt = false;

  for (int i = 0; i <= 5; i++) {
    memcpy(peerInfo.peer_addr, peerMac[i], 6);

    if (esp_now_add_peer(&peerInfo) != ESP_OK) {
      Serial.print("Failed to add peer ");
      Serial.println(i);
    }
  }
}

void sendData() {
  unsigned long currentTime = millis();
  if (currentTime - lastSendTime >= sendInterval) {
    lastSendTime = currentTime;
    std::array<float, 12> angles = calculateAngles();
    for (int i = 0; i <= 5; i++) {
      outgoingInformation.thetal = angles[0]; // Example assignment
      outgoingInformation.thetar = angles[1]; // Example assignment
      esp_now_send(peerMac[i],(uint8_t*)&outgoingInformation,sizeof(outgoingInformation));
    }
  }
}

// ==============================
// --- SETUP & LOOP ---
// ==============================

void setup() {
  Serial.begin(9600);
  // Set device as a Wi-Fi Station
  WiFi.mode(WIFI_STA);

  // Init ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }

  addPeers();

  // Once ESPNow is successfully Init, we will register for Send CB to
  // get the status of Trasnmitted packet
  esp_now_register_send_cb(esp_now_send_cb_t(OnDataSent));
  }


void loop() {
  processSerialInput();
  sendData();
}